// functions/api/create-post.js
export async function onRequestPost(context) {
    const corsHeaders = {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'POST, OPTIONS, GET',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };

    if (context.request.method === 'OPTIONS') {
        return new Response(null, { 
            status: 200,
            headers: corsHeaders 
        });
    }

    try {
        const { GITHUB_TOKEN } = context.env;
        if (!GITHUB_TOKEN) {
            console.error('‚ùå GITHUB_TOKEN not found in environment');
            return errorResponse('GITHUB_TOKEN not configured', 500, corsHeaders);
        }

        const formData = await context.request.json();
        const { 
            title, 
            description, 
            content, 
            image, 
            filename, 
            rating, 
            affiliateLink, 
            youtubeLink, 
            categories, 
            keyFeatures, 
            finalVerdict, 
            pros, 
            cons,
            relatedContent
        } = formData;

        if (!title?.trim() || !filename?.trim()) {
            return errorResponse('Title and Filename are required', 400, corsHeaders);
        }

        if (!filename.match(/^[a-z0-9-]+$/i)) {
            return errorResponse('Filename can only contain letters, numbers, and hyphens', 400, corsHeaders);
        }

        const markdownContent = generateSEOMarkdown({
            title: title.trim(),
            description: description?.trim(),
            content: content?.trim(),
            image: image?.trim(),
            filename: filename.trim(),
            rating: rating || 5,
            affiliateLink: affiliateLink?.trim(),
            youtubeLink: youtubeLink?.trim(),
            categories: categories?.trim(),
            keyFeatures: keyFeatures?.trim(),
            finalVerdict: finalVerdict?.trim(),
            pros: pros?.trim(),
            cons: cons?.trim(),
            relatedContent: relatedContent?.trim()
        });

        const result = await publishToGitHub({
            token: GITHUB_TOKEN,
            content: markdownContent,
            title: title.trim(),
            filename: filename.trim()
        });

        // Update posts index after successful post creation
        const indexUpdated = await updatePostsIndex({
            token: GITHUB_TOKEN,
            title: title.trim(),
            filename: filename.trim(),
            slug: generateSlug(title.trim())
        });

        console.log(`üìù Posts index update ${indexUpdated ? 'successful' : 'failed'}`);

        return successResponse({
            ...result,
            indexUpdated
        }, corsHeaders);

    } catch (error) {
        console.error('üí• Function Error:', error);
        return errorResponse(error.message, 500, corsHeaders);
    }
}

// Function to update posts-index.md
async function updatePostsIndex({ token, title, filename, slug }) {
    try {
        const REPO_OWNER = 'yourfreetools';
        const REPO_NAME = 'reviewindex';
        const postsIndexPath = 'content/posts-index.md';
        const currentDate = new Date().toISOString();
        
        console.log('üîÑ Starting posts index update...');
        
        let existingContent = '';
        let existingSha = null;

        // Try to get existing posts index file
        try {
            console.log('üìñ Fetching existing posts index from GitHub...');
            const getResponse = await fetch(
                `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${postsIndexPath}`,
                {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'User-Agent': 'Review-Index-App'
                    }
                }
            );

            console.log(`üì° GitHub GET response status: ${getResponse.status}`);
            
            if (getResponse.status === 200) {
                const data = await getResponse.json();
                console.log('‚úÖ Found existing posts index');
                existingSha = data.sha;
                
                // Decode the content
                existingContent = atob(data.content.replace(/\n/g, ''));
                console.log(`üìä Existing index content length: ${existingContent.length}`);
            } else if (getResponse.status === 404) {
                console.log('üìù No existing posts index found, will create new one');
                existingContent = `# Posts Index\n\nThis file is automatically generated and contains all published posts.\n\n| Title | Slug | Date | URL |\n|-------|------|------|-----|\n`;
            } else {
                console.warn(`‚ö†Ô∏è Unexpected status when fetching index: ${getResponse.status}`);
                // Start with basic structure if we can't read existing file
                existingContent = `# Posts Index\n\nThis file is automatically generated and contains all published posts.\n\n| Title | Slug | Date | URL |\n|-------|------|------|-----|\n`;
            }
        } catch (error) {
            console.log('üìù Error fetching existing index, creating new one...', error.message);
            existingContent = `# Posts Index\n\nThis file is automatically generated and contains all published posts.\n\n| Title | Slug | Date | URL |\n|-------|------|------|-----|\n`;
        }

        // Parse existing content and update with new post
        const updatedContent = updatePostsIndexContent(existingContent, {
            title,
            slug,
            filename: filename.endsWith('.md') ? filename : `${filename}.md`,
            date: currentDate
        });

        console.log('üì§ Uploading updated posts index to GitHub...');

        // Prepare the request body
        const requestBody = {
            message: `Update posts index: ${title}`,
            content: btoa(unescape(encodeURIComponent(updatedContent))),
            branch: 'main'
        };

        // Add SHA if we're updating an existing file
        if (existingSha) {
            requestBody.sha = existingSha;
            console.log('üìù Updating existing file with SHA');
        } else {
            console.log('üìù Creating new file');
        }

        // Update the posts index file
        const updateResponse = await fetch(
            `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${postsIndexPath}`,
            {
                method: 'PUT',
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json',
                    'Content-Type': 'application/json',
                    'User-Agent': 'Review-Index-App'
                },
                body: JSON.stringify(requestBody)
            }
        );

        console.log(`üì° GitHub PUT response status: ${updateResponse.status}`);

        if (!updateResponse.ok) {
            const errorData = await updateResponse.json();
            console.error('‚ùå GitHub API error:', {
                status: updateResponse.status,
                message: errorData.message
            });
            throw new Error(`GitHub API error: ${errorData.message || updateResponse.status}`);
        }

        console.log('‚úÖ Posts index updated successfully');
        return true;

    } catch (error) {
        console.error('‚ùå Error updating posts index:', error.message);
        // Don't throw the error - we don't want to fail the main post creation
        return false;
    }
}

// Helper function to update the markdown content
function updatePostsIndexContent(existingContent, newPost) {
    const { title, slug, filename, date } = newPost;
    const cleanFilename = filename.replace('.md', '');
    const url = `https://reviewindex.pages.dev/review/${cleanFilename}`;
    const formattedDate = date.split('T')[0];
    
    // Create the new row
    const newRow = `| ${title} | ${slug} | ${formattedDate} | ${url} |`;
    
    // Split the content into lines
    const lines = existingContent.split('\n');
    
    // Find the table header and the line after it
    let tableStartIndex = -1;
    let insertIndex = -1;
    
    for (let i = 0; i < lines.length; i++) {
        if (lines[i].startsWith('| Title | Slug | Date | URL |')) {
            tableStartIndex = i;
            insertIndex = i + 2; // Insert after header and separator line
            break;
        }
    }
    
    // If no table found, create a new one
    if (tableStartIndex === -1) {
        const newContent = `# Posts Index\n\nThis file is automatically generated and contains all published posts.\n\n| Title | Slug | Date | URL |\n|-------|------|------|-----|\n${newRow}\n`;
        return newContent;
    }
    
    // Check if post already exists in the table
    const postUrl = `review/${cleanFilename}`;
    let postExists = false;
    let existingRowIndex = -1;
    
    for (let i = insertIndex; i < lines.length; i++) {
        if (lines[i].includes(postUrl)) {
            postExists = true;
            existingRowIndex = i;
            break;
        }
    }
    
    let updatedLines;
    if (postExists) {
        // Update existing row
        console.log('üîÑ Updating existing post in index');
        updatedLines = [...lines];
        updatedLines[existingRowIndex] = newRow;
    } else {
        // Insert new row at the top of the table (after header and separator)
        console.log('‚ûï Adding new post to index');
        updatedLines = [
            ...lines.slice(0, insertIndex),
            newRow,
            ...lines.slice(insertIndex)
        ];
    }
    
    // Limit to 1000 posts to prevent file from getting too large
    const tableEndIndex = findTableEndIndex(updatedLines, insertIndex);
    if (tableEndIndex - insertIndex > 1000) {
        console.log('‚úÇÔ∏è Trimming posts table to 1000 entries');
        updatedLines = [
            ...updatedLines.slice(0, insertIndex),
            ...updatedLines.slice(insertIndex, insertIndex + 1000)
        ];
    }
    
    return updatedLines.join('\n');
}

// Helper function to find where the table ends
function findTableEndIndex(lines, startIndex) {
    for (let i = startIndex; i < lines.length; i++) {
        if (!lines[i].trim() || !lines[i].startsWith('|')) {
            return i;
        }
    }
    return lines.length;
}

// Helpers
function errorResponse(message, status = 500, headers) {
    return new Response(JSON.stringify({ 
        success: false, 
        message 
    }), { 
        status, 
        headers: { ...headers, 'Content-Type': 'application/json' } 
    });
}

function successResponse(data, headers) {
    return new Response(JSON.stringify({ 
        success: true, 
        message: 'üéâ SEO-optimized review published successfully!', 
        data 
    }), { 
        status: 200, 
        headers: { ...headers, 'Content-Type': 'application/json' } 
    });
}

// Markdown generator for the main post
function generateSEOMarkdown(data) {
    const currentDate = new Date().toISOString();
    const formattedDate = currentDate.split('T')[0];
    const slug = generateSlug(data.title);

    const categoryList = data.categories ? data.categories.split(',').map(c => `"${c.trim()}"`) : ["reviews"];

    const keyFeaturesList = data.keyFeatures?.split('\n').filter(f => f.trim()).map(f => `- ${f.trim()}`).join('\n');
    const prosList = data.pros?.split('\n').filter(p => p.trim()).map(p => `- ${p.trim()}`).join('\n');
    const consList = data.cons?.split('\n').filter(c => c.trim()).map(c => `- ${c.trim()}`).join('\n');
    
    const relatedContentList = data.relatedContent?.split('\n')
        .filter(url => url.trim())
        .map(url => {
            const cleanUrl = url.trim();
            const title = cleanUrl.replace(/^https?:\/\//, '')
                                .replace(/\/$/, '')
                                .split('/')
                                .pop()
                                .replace(/-/g, ' ')
                                .replace(/\.[^/.]+$/, '')
                                .replace(/\b\w/g, l => l.toUpperCase());
            return `- [${title}](${cleanUrl})`;
        })
        .join('\n');

    return `---
title: "${data.title.replace(/"/g, '\\"')}"
description: "${(data.description || `Comprehensive review of ${data.title}`).replace(/"/g, '\\"').substring(0, 160)}"
image: "${data.image || ''}"
rating: ${data.rating || 5}
affiliateLink: "${data.affiliateLink || ''}"
youtubeId: "${data.youtubeLink || ''}"
categories: [${categoryList.join(', ')}]
date: "${currentDate}"
slug: "${slug}"
draft: false
---

# ${data.title}

${data.image ? `![${data.title}](${data.image})` : ''}

${data.description || ''}

${data.content || 'Start your comprehensive review here...'}

${keyFeaturesList ? `
## Key Features

${keyFeaturesList}
` : ''}

${prosList ? `
## Pros üëç

${prosList}
` : ''}

${consList ? `
## Cons üëé

${consList}
` : ''}

## Final Rating: ${data.rating || 5}/5 ‚≠ê

${data.finalVerdict || '*Your final verdict and recommendation*'}

${relatedContentList ? `
## üìö Related Content

Check out these related articles and reviews:

${relatedContentList}
` : ''}

---

*Published on ${formattedDate}*
`;
}

function generateSlug(title) {
    return title.toLowerCase()
        .replace(/[^a-z0-9 -]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .substring(0, 60);
}

async function publishToGitHub({ token, content, title, filename }) {
    const REPO_OWNER = 'yourfreetools';
    const REPO_NAME = 'reviewindex';
    const finalFilename = filename.endsWith('.md') ? filename : `${filename}.md`;
    const filePath = `content/reviews/${finalFilename}`;
    
    // Use proper base64 encoding for GitHub
    const encodedContent = btoa(unescape(encodeURIComponent(content)));

    const response = await fetch(
        `https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/contents/${filePath}`, 
        {
            method: 'PUT',
            headers: { 
                'Authorization': `token ${token}`, 
                'Content-Type': 'application/json', 
                'User-Agent': 'Review-Index-App' 
            },
            body: JSON.stringify({ 
                message: `Add review: ${title}`, 
                content: encodedContent, 
                branch: 'main' 
            })
        }
    );

    const data = await response.json();
    if (!response.ok) {
        console.error('‚ùå GitHub publish error:', data);
        throw new Error(data.message || `GitHub API error: ${response.status}`);
    }

    return { 
        sha: data.content.sha, 
        url: data.content.html_url, 
        path: filePath, 
        siteUrl: `https://reviewindex.pages.dev/review/${filename.replace('.md','')}` 
    };
            }
